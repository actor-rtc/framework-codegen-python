"""
Code generation functions.

This module contains all the code generation logic for Python protobuf files.
"""

from __future__ import annotations

from typing import List, Dict
from dataclasses import dataclass


@dataclass
class RemoteServiceInfo:
    """Information about a remote service for proxying."""
    service_name: str
    route_keys: List[str]
    actr_type: str  # e.g., "acme+DataStreamConcurrentServer"


# ============================================================================
# Core Generation Functions (called by strategies)
# ============================================================================

def generate_empty_local_workload(
    package_name: str,
    proto_name: str,
    remote_services: List[RemoteServiceInfo],
) -> dict:
    """Generate a workload for an empty local proto that proxies remote services."""
    pkg_name = package_name.replace(".", "_").title() if package_name else "Client"
    workload_name = f"{pkg_name}Workload"
    dispatcher_name = f"{pkg_name}Dispatcher"  # 动态 Dispatcher 名称
    file_name = f"{to_snake_case(pkg_name)}_workload.py"
    
    # Don't import pb2 module for empty local proto (it won't be generated)
    preamble = "\n".join([
        "# DO NOT EDIT.",
        "# Generated by protoc-gen-actrframework-python",
        "from __future__ import annotations",
        "import abc",
        "from typing import Any",
        "from actr import WorkloadBase, Context, ActrType, Dest",
    ])
    
    sections: List[str] = [
        preamble,
        generate_empty_workload_with_proxy(workload_name, dispatcher_name, remote_services),
    ]
    
    content = "\n\n".join(section for section in sections if section)
    return {"name": file_name, "content": content}


def generate_remote_extensions_only(
    package_name: str,
    proto_name: str,
    service_name: str,
    methods,
) -> dict:
    """Generate RPC request extensions only (for remote services)."""
    proto_module = proto_module_name(proto_name)
    
    # Extract directory path from proto_name (e.g., "remote/echo-echo-server/echo.proto")
    # Output client file to the same directory as the pb2 file
    # Note: protoc converts hyphens to underscores in directory names
    proto_dir = proto_name.rsplit("/", 1)[0] if "/" in proto_name else ""
    # Convert hyphens to underscores to match protoc's output
    proto_dir = proto_dir.replace("-", "_") if proto_dir else ""
    file_base_name = f"{to_snake_case(service_name)}_client.py"
    file_name = f"{proto_dir}/{file_base_name}" if proto_dir else file_base_name
    
    # Use relative import since client file is in the same directory as pb2 file
    preamble = "\n".join([
        "# DO NOT EDIT.",
        "# Generated by protoc-gen-actrframework-python",
        "from __future__ import annotations",
        f"from . import {proto_module} as pb2",
    ])
    
    sections: List[str] = [
        preamble,
        generate_rpc_request_extensions(package_name, service_name, methods),
    ]
    
    content = "\n\n".join(section for section in sections if section)
    return {"name": file_name, "content": content}


def proto_module_name(proto_name: str) -> str:
    """Convert proto file name to module name (e.g., 'local/foo.proto' -> 'foo_pb2')."""
    # 只取文件名部分，去掉路径
    filename = proto_name.split("/")[-1]
    base = filename.replace(".proto", "")
    return f"{base}_pb2"


def generate_local_actor_code(
    package_name: str,
    proto_name: str,
    service_name: str,
    methods,
    remote_services: List[RemoteServiceInfo],
) -> str:
    """Generate complete actor code for a local service."""
    proto_module = proto_module_name(proto_name)
    
    preamble = generate_preamble(proto_module, use_relative_import=True, subdir="local")
    handler = generate_handler(f"{service_name}Handler", methods)
    dispatcher = generate_dispatcher(package_name, service_name, methods, remote_services)
    route_helpers = generate_route_helpers(package_name, service_name, methods)
    rpc_extensions = generate_rpc_request_extensions(package_name, service_name, methods)
    workload = generate_workload(service_name)
    
    sections: List[str] = [
        preamble,
        handler,
        dispatcher,
        route_helpers,
        rpc_extensions,
        workload,
    ]
    
    return "\n\n".join(section for section in sections if section)


# ============================================================================
# Helper Generation Functions
# ============================================================================

def generate_preamble(proto_module: str, use_relative_import: bool = False, subdir: str = "") -> str:
    """Generate preamble with imports."""
    # proto_module 已经包含了文件名（如 "echo_pb2"）
    # subdir 是子目录（如 "local"）
    if use_relative_import and subdir:
        import_line = f"from .{subdir} import {proto_module} as pb2"
    elif use_relative_import:
        import_line = f"from . import {proto_module} as pb2"
    else:
        import_line = f"import {proto_module} as pb2"
    
    return "\n".join([
        "# DO NOT EDIT.",
        "# Generated by protoc-gen-actrframework-python",
        "from __future__ import annotations",
        "import abc",
        "from typing import Any",
        "from actr import WorkloadBase, Context, ActrType, Dest",
        import_line,
    ])


def generate_handler(handler_name: str, methods) -> str:
    """Generate abstract handler class."""
    lines: List[str] = [f"class {handler_name}(abc.ABC):"]
    
    for method in methods:
        method_name = to_snake_case(method.name)
        input_type = extract_message_type(method.input_type)
        output_type = extract_message_type(method.output_type)
        
        lines.append(f"    @abc.abstractmethod")
        lines.append(f"    async def {method_name}(self, req: pb2.{input_type}, ctx: Context) -> pb2.{output_type}:")
        lines.append(f"        raise NotImplementedError")
        lines.append("")
    
    return "\n".join(lines)


def generate_dispatcher(
    package_name: str,
    service_name: str,
    methods,
    remote_services: List[RemoteServiceInfo],
) -> str:
    """Generate dispatcher class."""
    lines: List[str] = [
        f"class {service_name}Dispatcher:",
        "    async def dispatch(self, workload, route_key: str, payload: bytes, ctx: Any) -> bytes:",
        "        handler = getattr(workload, \"handler\", workload)",
        "        if not isinstance(ctx, Context):",
        "            ctx = Context(ctx)",
        "",
        "        # Local methods",
        "        local_route = _resolve_local_route(route_key)",
        "        if local_route:",
        "            method_name, req_cls, resp_cls = local_route",
        "            req = req_cls.FromString(payload)",
        "            resp = await getattr(handler, method_name)(req, ctx)",
        "            return _encode_response(resp, resp_cls)",
        "",
    ]
    
    # Add remote service proxying if there are remote dependencies
    if remote_services:
        lines.append("        # Remote methods (proxying)")
        for remote in remote_services:
            route_keys_str = ", ".join(f'"{rk}"' for rk in remote.route_keys)
            lines.append(f"        if route_key in [{route_keys_str}]:")
            
            # Parse actr_type (e.g., "acme+DataStreamConcurrentServer")
            if "+" not in remote.actr_type:
                raise ValueError(
                    f"Invalid actr_type format for remote service '{remote.service_name}': '{remote.actr_type}'. "
                    f"Expected format: 'manufacturer+name' (e.g., 'acme+ServiceName')"
                )
            
            parts = remote.actr_type.split("+", 1)
            remote_manufacturer = parts[0]
            remote_name = parts[1]
            
            lines.append(f"            target_type = ActrType(manufacturer=\"{remote_manufacturer}\", name=\"{remote_name}\")")
            lines.append("            target_id = await ctx.discover(target_type)")
            lines.append("            return await ctx._rust.call_raw(Dest.actor(target_id), route_key, payload)")
            lines.append("")
    
    lines.append("        raise RuntimeError(f\"Unknown route_key: {route_key}\")")
    
    return "\n".join(lines)


def generate_route_helpers(package_name: str, service_name: str, methods) -> str:
    """Generate route helper functions."""
    lines: List[str] = ["LOCAL_ROUTES = {"]
    
    for method in methods:
        route_key = make_route_key(package_name, service_name, method.name)
        method_name = to_snake_case(method.name)
        input_type = extract_message_type(method.input_type)
        output_type = extract_message_type(method.output_type)
        lines.append(f"    \"{route_key}\": (\"{method_name}\", pb2.{input_type}, pb2.{output_type}),")
    
    lines.append("}")
    lines.append("")
    lines.append("def _resolve_local_route(route_key: str):")
    lines.append("    return LOCAL_ROUTES.get(route_key)")
    lines.append("")
    lines.append("def _encode_response(resp, resp_cls):")
    lines.append("    if not isinstance(resp, resp_cls):")
    lines.append("        raise ValueError(\"Response must match the declared protobuf type\")")
    lines.append("    return resp.SerializeToString()")
    
    return "\n".join(lines)


def generate_rpc_request_extensions(
    package_name: str,
    service_name: str,
    methods,
) -> str:
    """Generate RPC request extensions (add route_key and Response to request messages)."""
    lines: List[str] = ["# RPC Request Extensions"]
    
    for method in methods:
        route_key = make_route_key(package_name, service_name, method.name)
        input_type = extract_message_type(method.input_type)
        output_type = extract_message_type(method.output_type)
        
        lines.append(f"pb2.{input_type}.route_key = \"{route_key}\"")
        lines.append(f"pb2.{input_type}.Response = pb2.{output_type}")
    
    return "\n".join(lines)


def generate_workload(service_name: str) -> str:
    """Generate workload class."""
    return "\n".join([
        f"class {service_name}Workload(WorkloadBase):",
        f"    def __init__(self, handler: {service_name}Handler):",
        "        self.handler = handler",
        f"        super().__init__({service_name}Dispatcher())",
    ])


def generate_empty_workload_with_proxy(
    workload_name: str,
    dispatcher_name: str,  # 新增参数
    remote_services: List[RemoteServiceInfo],
) -> str:
    """Generate a workload for empty local proto that only proxies remote services."""
    lines: List[str] = [
        f"# {workload_name} - automatically generated for empty local proto",
        f"class {dispatcher_name}:",  # 使用动态名称
        "    async def dispatch(self, workload, route_key: str, payload: bytes, ctx: Any) -> bytes:",
        "        if not isinstance(ctx, Context):",
        "            ctx = Context(ctx)",
        "",
    ]
    
    if remote_services:
        lines.append("        # Remote methods (proxying)")
        for remote in remote_services:
            route_keys_str = ", ".join(f'"{rk}"' for rk in remote.route_keys)
            lines.append(f"        if route_key in [{route_keys_str}]:")
            
            # Parse actr_type (e.g., "acme+DataStreamConcurrentServer")
            if "+" not in remote.actr_type:
                raise ValueError(
                    f"Invalid actr_type format for remote service '{remote.service_name}': '{remote.actr_type}'. "
                    f"Expected format: 'manufacturer+name' (e.g., 'acme+ServiceName')"
                )
            
            parts = remote.actr_type.split("+", 1)
            remote_manufacturer = parts[0]
            remote_name = parts[1]
            
            lines.append(f"            target_type = ActrType(manufacturer=\"{remote_manufacturer}\", name=\"{remote_name}\")")
            lines.append("            target_id = await ctx.discover(target_type)")
            lines.append("            return await ctx._rust.call_raw(Dest.actor(target_id), route_key, payload)")
            lines.append("")
    
    lines.append("        raise RuntimeError(f\"Unknown route_key: {route_key}\")")
    lines.append("")
    lines.append(f"class {workload_name}(WorkloadBase):")
    lines.append("    def __init__(self):")
    lines.append(f"        super().__init__({dispatcher_name}())")  # 使用动态名称
    
    return "\n".join(lines)


def generate_client_workload(
    remote_services: List[RemoteServiceInfo],
) -> dict:
    """Generate a generic client workload for proxying remote services only.
    
    This is used when a client has remote service dependencies but no local proto files.
    """
    preamble = generate_client_preamble()
    dispatcher = generate_client_dispatcher(remote_services)
    workload = generate_client_workload_class()
    
    sections: List[str] = [preamble, dispatcher, workload]
    content = "\n\n".join(section for section in sections if section)
    
    return {"name": "default_workload.py", "content": content}


def generate_client_preamble() -> str:
    """Generate preamble for client workload."""
    return "\n".join([
        "# DO NOT EDIT.",
        "# Generated by protoc-gen-actrframework-python",
        "from __future__ import annotations",
        "from typing import Any",
        "from actr import WorkloadBase, Context, ActrType, Dest",
    ])


def generate_client_dispatcher(
    remote_services: List[RemoteServiceInfo],
) -> str:
    """Generate dispatcher for client workload."""
    lines: List[str] = [
        "class DefaultDispatcher:",
        "    async def dispatch(self, workload, route_key: str, payload: bytes, ctx: Any) -> bytes:",
        "        if not isinstance(ctx, Context):",
        "            ctx = Context(ctx)",
        "",
    ]
    
    if remote_services:
        lines.append("        # Remote methods (proxying)")
        for remote in remote_services:
            route_keys_str = ", ".join(f'"{rk}"' for rk in remote.route_keys)
            lines.append(f"        if route_key in [{route_keys_str}]:")
            
            parts = remote.actr_type.split("+", 1)
            remote_manufacturer = parts[0]
            remote_name = parts[1]
            
            lines.append(f"            target_type = ActrType(manufacturer=\"{remote_manufacturer}\", name=\"{remote_name}\")")
            lines.append("            target_id = await ctx.discover(target_type)")
            lines.append("            return await ctx._rust.call_raw(Dest.actor(target_id), route_key, payload)")
            lines.append("")
    
    lines.append("        raise RuntimeError(f\"Unknown route_key: {route_key}\")")
    
    return "\n".join(lines)


def generate_client_workload_class() -> str:
    """Generate workload class for client."""
    return "\n".join([
        "class DefaultWorkload(WorkloadBase):",
        "    def __init__(self):",
        "        super().__init__(DefaultDispatcher())",
    ])


# ============================================================================
# Utility Functions
# ============================================================================

def extract_message_type(full_type: str) -> str:
    """Extract message type name from full type path (e.g., '.echo.EchoRequest' -> 'EchoRequest')."""
    return full_type.split(".")[-1]


def to_snake_case(name: str) -> str:
    """Convert CamelCase to snake_case."""
    import re
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()


def make_route_key(package_name: str, service_name: str, method_name: str) -> str:
    """Generate route key for a method (e.g., 'echo.EchoService.Echo')."""
    return f"{package_name}.{service_name}.{method_name}"


def ensure_no_streaming_methods(methods) -> None:
    """Ensure no streaming methods are present (not supported yet)."""
    for method in methods:
        if method.client_streaming or method.server_streaming:
            raise NotImplementedError(
                f"Streaming methods are not supported yet: {method.name}"
            )
