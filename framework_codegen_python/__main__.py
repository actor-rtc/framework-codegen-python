from __future__ import annotations

import sys
from typing import List

from google.protobuf.compiler import plugin_pb2 as plugin


def main() -> int:
    data = sys.stdin.buffer.read()
    request = plugin.CodeGeneratorRequest()
    request.ParseFromString(data)

    response = plugin.CodeGeneratorResponse()
    response.supported_features = 1

    for file_name in request.file_to_generate:
        file_desc = next((f for f in request.proto_file if f.name == file_name), None)
        if file_desc is None:
            continue
        for service in file_desc.service:
            output = generate_service_code(
                file_desc.package,
                file_desc.name,
                service.name,
                service.method,
            )
            f = response.file.add()
            f.name = output["name"]
            f.content = output["content"]

    sys.stdout.buffer.write(response.SerializeToString())
    return 0


def generate_service_code(
    package_name: str,
    proto_name: str,
    service_name: str,
    methods,
):
    ensure_no_streaming_methods(service_name, methods)
    module_name = proto_module_name(proto_name)
    file_name = f"{to_snake_case(service_name)}_actor.py"
    content = generate_python_code(
        package_name=package_name,
        service_name=service_name,
        proto_module=module_name,
        methods=methods,
    )
    return {"name": file_name, "content": content}


def proto_module_name(proto_path: str) -> str:
    file_name = proto_path.rsplit("/", 1)[-1]
    stem = file_name[:-6] if file_name.endswith(".proto") else file_name
    return f"{stem}_pb2"


def generate_python_code(
    package_name: str,
    service_name: str,
    proto_module: str,
    methods,
) -> str:
    handler_name = f"{service_name}Handler"
    dispatcher_name = f"{service_name}Dispatcher"
    workload_name = f"{service_name}Workload"

    sections: List[str] = [
        generate_preamble(proto_module),
        generate_handler(handler_name, methods),
        generate_dispatcher(dispatcher_name, methods),
    ]

    if methods:
        sections.append(generate_route_helpers(package_name, service_name, methods))

    sections.append(generate_workload(workload_name, handler_name, dispatcher_name))

    return "\n\n".join(section for section in sections if section)


def generate_preamble(proto_module: str) -> str:
    return "\n".join(
        [
            "# Auto-generated by framework_codegen_python. DO NOT EDIT.",
            "from __future__ import annotations",
            "import abc",
            "from typing import Any",
            "from actr import WorkloadBase",
            f"import {proto_module} as pb2",
        ]
    )


def generate_handler(handler_name: str, methods) -> str:
    lines: List[str] = [f"class {handler_name}(abc.ABC):"]
    if not methods:
        lines.append("    pass")
        return "\n".join(lines)

    for method in methods:
        method_name = to_snake_case(method.name)
        input_type = extract_message_type(method.input_type)
        output_type = extract_message_type(method.output_type)
        lines.append("    @abc.abstractmethod")
        lines.append(
            f"    async def {method_name}(self, req: pb2.{input_type}, ctx: Any) -> pb2.{output_type}:"
        )
        lines.append("        raise NotImplementedError")
        lines.append("")

    return "\n".join(lines).rstrip()


def generate_dispatcher(dispatcher_name: str, methods) -> str:
    lines: List[str] = [
        f"class {dispatcher_name}:",
        "    async def dispatch(self, workload, route_key: str, payload: bytes, ctx: Any) -> bytes:",
        "        handler = getattr(workload, \"handler\", workload)",
    ]

    if not methods:
        lines.append("        raise RuntimeError(\"No RPC methods defined\")")
    else:
        lines.append("        method_name, req_cls, resp_cls = _resolve_route(route_key)")
        lines.append("        req = req_cls.FromString(payload)")
        lines.append("        resp = await getattr(handler, method_name)(req, ctx)")
        lines.append("        return _encode_response(resp, resp_cls)")

    return "\n".join(lines)


def generate_route_helpers(package_name: str, service_name: str, methods) -> str:
    lines: List[str] = ["ROUTES = {"]
    for method in methods:
        method_name = to_snake_case(method.name)
        input_type = extract_message_type(method.input_type)
        output_type = extract_message_type(method.output_type)
        route_key = make_route_key(package_name, service_name, method.name)
        lines.append(
            f"    \"{route_key}\": (\"{method_name}\", pb2.{input_type}, pb2.{output_type}),"
        )
    lines.append("}")
    lines.append("")
    lines.append("def _resolve_route(route_key: str):")
    lines.append("    try:")
    lines.append("        return ROUTES[route_key]")
    lines.append("    except KeyError as exc:")
    lines.append("        raise RuntimeError(f\"Unknown route_key: {route_key}\") from exc")
    lines.append("")
    lines.append("def _encode_response(resp, resp_cls):")
    lines.append("    if not isinstance(resp, resp_cls):")
    lines.append("        raise ValueError(\"Response must match the declared protobuf type\")")
    lines.append("    return resp.SerializeToString()")
    return "\n".join(lines)


def generate_workload(
    workload_name: str,
    handler_name: str,
    dispatcher_name: str,
) -> str:
    lines: List[str] = [
        f"class {workload_name}(WorkloadBase):",
        f"    def __init__(self, handler: {handler_name}):",
        "        self.handler = handler",
        f"        super().__init__({dispatcher_name}())",
    ]
    return "\n".join(lines)


def extract_message_type(type_name: str) -> str:
    cleaned = type_name.lstrip(".")
    return cleaned.split(".")[-1]


def to_snake_case(name: str) -> str:
    out = []
    for i, ch in enumerate(name):
        if ch.isupper() and i != 0:
            out.append("_")
        out.append(ch.lower())
    return "".join(out)


def make_route_key(package_name: str, service_name: str, method_name: str) -> str:
    if package_name:
        return f"{package_name}.{service_name}.{method_name}"
    return f"{service_name}.{method_name}"


def ensure_no_streaming_methods(service_name: str, methods) -> None:
    for method in methods:
        if method.client_streaming or method.server_streaming:
            raise ValueError(
                f"Streaming RPC is not supported for {service_name}.{method.name}"
            )


if __name__ == "__main__":
    raise SystemExit(main())
