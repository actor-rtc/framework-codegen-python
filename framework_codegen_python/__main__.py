# Auto-generated by framework_codegen_python. DO NOT EDIT.
from __future__ import annotations

import sys
from typing import List, Dict

from google.protobuf.compiler import plugin_pb2 as plugin

# Import from generators module
from .generators import RemoteServiceInfo, make_route_key, ensure_no_streaming_methods


def main() -> int:
    """Main entry point for the protoc plugin."""
    data = sys.stdin.buffer.read()
    request = plugin.CodeGeneratorRequest()
    request.ParseFromString(data)

    # Parse parameters
    parameters = parse_parameters(request.parameter)

    # Parse LocalFiles (unified parameter name)
    local_files_str = parameters.get("LocalFiles", "")
    local_files_set = set(f for f in local_files_str.split(":") if f)
    
    # Parse RemoteFileMapping in format: path1=actr_type1:path2=actr_type2
    remote_mapping_str = parameters.get("RemoteFileMapping", "")
    remote_file_to_actr_type: Dict[str, str] = {}
    
    if remote_mapping_str:
        for pair in remote_mapping_str.split(":"):
            if "=" in pair:
                file_path, actr_type = pair.split("=", 1)
                if file_path and actr_type:
                    remote_file_to_actr_type[file_path] = actr_type
                else:
                    print(f"WARNING: Invalid mapping pair: {pair}", file=sys.stderr)
            else:
                print(f"WARNING: Invalid mapping format (missing '='): {pair}", file=sys.stderr)
    
    print(f"DEBUG: Parsed {len(remote_file_to_actr_type)} remote file mappings", file=sys.stderr)
    print(f"DEBUG: Parsed {len(local_files_set)} local files", file=sys.stderr)
 
    # First pass: Collect info about all Remote services
    remote_services: List[RemoteServiceInfo] = []
    for file_desc in request.proto_file:
        # Normalize file path for comparison
        normalized_file_name = file_desc.name.replace("\\", "/")
        
        # Determine if this file is remote
        is_remote = normalized_file_name in remote_file_to_actr_type
        
        if is_remote:
            # Get actr_type for this file from the mapping
            actr_type = remote_file_to_actr_type.get(normalized_file_name, "")
            
            # Critical: Do NOT fallback - fail fast if actr_type is missing
            if not actr_type:
                print(
                    f"ERROR: Remote file '{file_desc.name}' found but has no actr_type mapping.",
                    file=sys.stderr
                )
                print(
                    f"Available mappings: {list(remote_file_to_actr_type.keys())}",
                    file=sys.stderr
                )
                sys.exit(1)
            
            for service in file_desc.service:
                route_keys = []
                for method in service.method:
                    route_key = make_route_key(file_desc.package, service.name, method.name)
                    route_keys.append(route_key)
                remote_services.append(
                    RemoteServiceInfo(
                        service_name=service.name, 
                        route_keys=route_keys,
                        actr_type=actr_type
                    )
                )
                print(
                    f"INFO: Registered remote service '{service.name}' with actr_type '{actr_type}'",
                    file=sys.stderr
                )


    # Second pass: Generate content for each file using Strategy Pattern
    response = plugin.CodeGeneratorResponse()
    response.supported_features = plugin.CodeGeneratorResponse.FEATURE_PROTO3_OPTIONAL

    # Import strategy classes
    from .strategies import GenerationContext, StrategySelector
    from .concrete_strategies import (
        create_default_strategies,
        DefaultClientWorkloadStrategy,
    )

    # Create generation context
    context = GenerationContext(
        remote_file_to_actr_type=remote_file_to_actr_type,
        local_files_set=local_files_set,
        remote_services=remote_services,
    )

    # Create strategy selector with default strategies
    selector = StrategySelector(create_default_strategies())

    # Process each file using the appropriate strategy
    for file_name in request.file_to_generate:
        file_desc = next((f for f in request.proto_file if f.name == file_name), None)
        if file_desc is None:
            continue

        # Skip files without services and not explicitly marked as local
        if not file_desc.service and not context.is_local(file_desc):
            print(
                f"DEBUG: Skipping file '{file_desc.name}' (no services, not local)",
                file=sys.stderr
            )
            continue

        # Select and apply the appropriate strategy
        strategy = selector.select_strategy(file_desc, context)
        if strategy:
            generated_files = strategy.generate(file_desc, context)
            for gen_file in generated_files:
                f = response.file.add()
                f.name = gen_file.name
                f.content = gen_file.content

    # Generate default client workload if needed
    if DefaultClientWorkloadStrategy.should_generate(context):
        gen_file = DefaultClientWorkloadStrategy.generate_default_workload(context)
        f = response.file.add()
        f.name = gen_file.name
        f.content = gen_file.content


    # Generate __init__.py for all directories involved
    generated_dirs = set()
    for f in response.file:
        if "/" in f.name:
            # Collect all parent directories
            path_parts = f.name.split("/")[:-1]
            current_path = ""
            for part in path_parts:
                current_path = f"{current_path}/{part}" if current_path else part
                generated_dirs.add(current_path)

    # Add __init__.py for the root directory if we have any files
    if len(response.file) > 0:
        f = response.file.add()
        f.name = "__init__.py"
        f.content = ""

    # Add __init__.py for all subdirectories
    for directory in sorted(generated_dirs):
        f = response.file.add()
        f.name = f"{directory}/__init__.py"
        f.content = ""

    sys.stdout.buffer.write(response.SerializeToString())
    return 0


def parse_parameters(param_str: str) -> Dict[str, str]:
    """Parse protoc plugin parameters in key=value format."""
    if not param_str:
        return {}
    
    params = {}
    for pair in param_str.split(","):
        parts = pair.split("=", 1)
        if len(parts) == 2:
            params[parts[0]] = parts[1]
        else:
            params[parts[0]] = ""
    return params




if __name__ == "__main__":
    raise SystemExit(main())
