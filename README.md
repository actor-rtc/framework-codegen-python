# framework_codegen_python

**Protoc plugin for generating Actr Python framework code**

A `protoc` plugin that automatically generates Python glue code for the Actr distributed actor framework from protobuf service definitions.

## What It Does

Generates all the boilerplate code needed to integrate your protobuf services with the Actr runtime:

- **Handler base classes** - Abstract classes for implementing your business logic
- **Dispatchers** - Routes incoming messages to the correct handler methods
- **Workload wrappers** - Integrates with ActrSystem
- **RPC extensions** - Adds convenience attributes to protobuf messages (route_key, Response type)
- **Remote service proxies** - Automatically handles calls to remote services

## Example

From this protobuf definition:

```protobuf
syntax = "proto3";
package echo;

message EchoRequest {
  string message = 1;
}

message EchoResponse {
  string reply = 1;
  int64 timestamp = 2;
}

service EchoService {
  rpc Echo (EchoRequest) returns (EchoResponse);
}
```

Generates this Python code:

```python
# Handler base class - you implement this
class EchoServiceHandler(abc.ABC):
    @abc.abstractmethod
    async def echo(self, req: pb2.EchoRequest, ctx: Context) -> pb2.EchoResponse:
        raise NotImplementedError

# Dispatcher - generated automatically
class EchoServiceDispatcher:
    async def dispatch(self, workload, route_key: str, payload: bytes, ctx: Any) -> bytes:
        # Routes messages to handler methods

# Workload - generated automatically
class EchoServiceWorkload(WorkloadBase):
    def __init__(self, handler: EchoServiceHandler):
        self.handler = handler
        super().__init__(EchoServiceDispatcher())

# RPC extensions - generated automatically
pb2.EchoRequest.route_key = "echo.EchoService.Echo"
pb2.EchoRequest.Response = pb2.EchoResponse
```

## Installation

```bash
pip install framework_codegen_python
```

## Usage

### Via actr CLI (Recommended)

```bash
# Generate code for your project
actr gen --input protos --output generated --language python
```

This will:
1. Read your `.proto` files from `protos/local/` and `protos/remote/`
2. Generate Python code in the `generated/` directory
3. Format the code with `black`
4. Validate the generated code

### Generated File Structure

```
generated/
├── __init__.py
├── local/                          # Local service protobuf files
│   ├── __init__.py
│   └── echo_pb2.py                 # Generated by protoc
├── echo_service_actor.py           # Generated by this plugin ✨
└── remote/                         # Remote service dependencies
    ├── __init__.py
    └── server_name/
        ├── __init__.py
        ├── server_pb2.py           # Generated by protoc
        └── server_client.py        # Generated by this plugin ✨
```

## Using the Generated Code

### Server Implementation

```python
from actr import ActrSystem, Context
from generated.local import echo_pb2 as pb2
from generated import echo_service_actor

# 1. Implement the handler
class EchoService(echo_service_actor.EchoServiceHandler):
    async def echo(self, req: pb2.EchoRequest, ctx: Context) -> pb2.EchoResponse:
        return pb2.EchoResponse(
            reply=f"Echo: {req.message}",
            timestamp=int(time.time())
        )

# 2. Create workload and start
async def main():
    system = await ActrSystem.from_toml("Actr.toml")
    workload = echo_service_actor.EchoServiceWorkload(EchoService())
    node = system.attach(workload)
    ref = await node.start()
    await ref.wait_for_ctrl_c_and_shutdown()
```

### Client Implementation

```python
from actr import ActrSystem, Dest
from generated.local import client_pb2 as pb2
from generated.remote.echo_server import echo_pb2 as server_pb2
from generated import client_workload

async def main():
    system = await ActrSystem.from_toml("Actr.toml")
    workload = client_workload.ClientWorkload()
    node = system.attach(workload)
    ref = await node.start()
    
    # Call remote service using generated RPC extensions
    request = server_pb2.EchoRequest(message="Hello")
    response_bytes = await ref.call(
        request.route_key,  # ✨ Auto-generated
        request
    )
    response = server_pb2.EchoResponse.FromString(response_bytes)
    print(f"Response: {response.reply}")
```

## Import Guidelines

### For Local Services

```python
# Import pb2 from generated/local/
from generated.local import echo_pb2 as pb2

# Import actor code from generated/
from generated import echo_service_actor
```

### For Remote Services

```python
# Import pb2 from generated/remote/{service_name}/
from generated.remote.echo_server import echo_pb2 as remote_pb2

# Import client extensions from the same directory
from generated.remote.echo_server import echo_service_client
```

## Advanced Usage

### Via protoc Directly

If you need more control, you can call `protoc` directly:

```bash
protoc -I protos \
  --python_out=generated \
  --plugin=protoc-gen-actrpython=$(which framework_codegen_python) \
  --actrpython_out=generated \
  --actrpython_opt=LocalFiles=local/echo.proto \
  protos/local/echo.proto
```

### With Remote Dependencies

```bash
protoc -I protos \
  --python_out=generated \
  --plugin=protoc-gen-actrpython=$(which framework_codegen_python) \
  --actrpython_out=generated \
  --actrpython_opt=LocalFiles=local/client.proto,RemoteFileMapping=remote/server/server.proto=acme+ServerService \
  protos/local/client.proto protos/remote/server/server.proto
```

## Requirements

- Python >= 3.9
- protobuf >= 4.21.0
- actr (Python bindings for Actr runtime)

## Version History

### 0.1.0-beta.3 (2026-01-16)
- Fixed remote service client file generation location
- Refactored code generation logic for better maintainability
- Improved import path handling

### 0.1.0-beta.2
- Initial strategy-based code generation
- Support for local and remote services

## License

See the main Actr project for license information.
